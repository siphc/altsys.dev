<!DOCTYPE html>
<html lang="en">
<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
  
    <title>What The Heck is an Arena? :: Terminal</title>
  
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="Imagine this scenario. You are developing an AST builder for your new shiny compiler; at some point in the program, you come up with this schema for dealing with floating point arithmetic..." />
<meta name="keywords" content="" />

  <meta name="robots" content="noodp" />

<link rel="canonical" href="//localhost:1313/posts/c-arena/" />





  
  <link rel="stylesheet" href="//localhost:1313/css/buttons.min.86f6b4c106b6c6eb690ae5203d36b442c1f66f718ff4e8164fa86cf6c61ad641.css">

  
  <link rel="stylesheet" href="//localhost:1313/css/code.min.d529ea4b2fb8d34328d7d31afc5466d5f7bc2f0bc9abdd98b69385335d7baee4.css">

  
  <link rel="stylesheet" href="//localhost:1313/css/fonts.min.5bb7ed13e1d00d8ff39ea84af26737007eb5051b157b86fc24487c94f3dc8bbe.css">

  
  <link rel="stylesheet" href="//localhost:1313/css/footer.min.eb8dfc2c6a7eafa36cd3ba92d63e69e849e2200e0002a228d137f236b09ecd75.css">

  
  <link rel="stylesheet" href="//localhost:1313/css/gist.min.a751e8b0abe1ba8bc53ced52a38b19d8950fe78ca29454ea8c2595cf26aad5c0.css">

  
  <link rel="stylesheet" href="//localhost:1313/css/header.min.75c7eb0e2872d95ff48109c6647d0223a38db52e2561dd87966eb5fc7c6bdac6.css">

  
  <link rel="stylesheet" href="//localhost:1313/css/main.min.36833afd348409fc6c3d09d0897c5833d9d5bf1ff31f5e60ea3ee42ce2b1268c.css">

  
  <link rel="stylesheet" href="//localhost:1313/css/menu.min.3c17467ebeb3d38663dce68f71f519901124fa5cbb4519b2fb0667a21e9aca39.css">

  
  <link rel="stylesheet" href="//localhost:1313/css/pagination.min.bbb986dbce00a5ce5aca0504b7925fc1c581992a4bf57f163e5d69cc1db7d836.css">

  
  <link rel="stylesheet" href="//localhost:1313/css/post.min.e6dddd258e64c83e05cec0cd49c05216742d42fc8ecbfbe6b67083412b609bd3.css">

  
  <link rel="stylesheet" href="//localhost:1313/css/syntax.min.a0773cce9310cb6d8ed23e50f005448facf29a53001b57e038828daa466b25c0.css">

  
  <link rel="stylesheet" href="//localhost:1313/css/terminal.min.e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855.css">

  
  <link rel="stylesheet" href="//localhost:1313/css/terms.min.b81791663c3790e738e571cdbf802312390d30e4b1d8dc9d814a5b5454d0ac11.css">







<link rel="shortcut icon" href="//localhost:1313/favicon.png">
<link rel="apple-touch-icon" href="//localhost:1313/apple-touch-icon.png">


<meta name="twitter:card" content="summary" />

  
    <meta name="twitter:site" content="" />
  
    <meta name="twitter:creator" content="William Pan" />



<meta property="og:locale" content="en" />
<meta property="og:type" content="article" />
<meta property="og:title" content="What The Heck is an Arena?">
<meta property="og:description" content="Imagine this scenario. You are developing an AST builder for your new shiny compiler; at some point in the program, you come up with this schema for dealing with floating point arithmetic..." />
<meta property="og:url" content="//localhost:1313/posts/c-arena/" />
<meta property="og:site_name" content="Terminal" />

  <meta property="og:image" content="//localhost:1313/og-image.png">

<meta property="og:image:width" content="1200">
<meta property="og:image:height" content="627">


  <meta property="article:published_time" content="2025-12-07 00:00:00 &#43;0000 UTC" />












</head>
<body>


<div class="container center">

  <header class="header">
  <div class="header__inner">
    <div class="header__logo">
      <a href="/">
  <div class="logo">
    altsys.dev
  </div>
</a>

    </div>
    
      <ul class="menu menu--mobile">
  <li class="menu__trigger">Menu&nbsp;▾</li>
  <li>
    <ul class="menu__dropdown">
      
        
          <li><a href="/about">About</a></li>
        
      
        
          <li><a href="/showcase">Showcase</a></li>
        
      
      
    </ul>
  </li>
</ul>

    
    
  </div>
  
    <nav class="navigation-menu">
  <ul class="navigation-menu__inner menu--desktop">
    
      
        
          <li><a href="/about" >About</a></li>
        
      
        
          <li><a href="/showcase" >Showcase</a></li>
        
      
      
    
  </ul>
</nav>

  
</header>


  <div class="content">
    
<article class="post">
  <h1 class="post-title">
    <a href="//localhost:1313/posts/c-arena/">What The Heck is an Arena?</a>
  </h1>
  <div class="post-meta"><time class="post-date">2025-12-07</time><span class="post-author">William Pan</span><span class="post-reading-time">5 min read (1020 words)</span></div>

  
    <span class="post-tags">
      
      #<a href="//localhost:1313/tags/c/">c</a>&nbsp;
      
    </span>
  
  


  

  <div class="post-content"><div>
        <h3 id="introduction">Introduction<a href="#introduction" class="hanchor" ariaLabel="Anchor">#</a> </h3>
<p>Imagine this scenario. You are developing an AST builder for your new shiny compiler; at some point in the program, you come up with this schema for dealing with floating point arithmetic:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">typedef</span> <span class="k">enum</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">NODE_NUMBER</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="n">NODE_VAR</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="n">NODE_BINOP</span><span class="p">,</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span> <span class="n">NodeType</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">typedef</span> <span class="k">struct</span> <span class="n">Node</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">NodeType</span> <span class="n">type</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">union</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="kt">double</span> <span class="n">number</span><span class="p">;</span>              <span class="c1">// NODE_NUMBER
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>           <span class="c1">// NODE_VAR
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">struct</span> <span class="p">{</span>                    <span class="c1">// NODE_BINOP
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="kt">char</span> <span class="n">op</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="k">struct</span> <span class="n">Node</span> <span class="o">*</span><span class="n">left</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="k">struct</span> <span class="n">Node</span> <span class="o">*</span><span class="n">right</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span> <span class="n">binop</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span> <span class="n">Node</span><span class="p">;</span>
</span></span></code></pre></div><p>Because you haven&rsquo;t heard of arenas yet, you go with the obvious approach, which inevitably leaves your code looking something like this:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">static</span> <span class="n">Node</span> <span class="o">*</span><span class="nf">make_number</span><span class="p">(</span><span class="kt">double</span> <span class="n">num</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">Node</span> <span class="o">*</span><span class="n">n</span> <span class="o">=</span> <span class="nf">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">Node</span><span class="p">));</span>	<span class="c1">// OK, looks alright.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">n</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="n">NODE_NUMBER</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">n</span><span class="o">-&gt;</span><span class="n">number</span> <span class="o">=</span> <span class="n">num</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">n</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">static</span> <span class="n">Node</span> <span class="o">*</span><span class="nf">make_var</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">Node</span> <span class="o">*</span><span class="n">n</span> <span class="o">=</span> <span class="nf">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">Node</span><span class="p">));</span>	<span class="c1">// malloc() once for the node...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">n</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="n">NODE_VAR</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">n</span><span class="o">-&gt;</span><span class="n">name</span> <span class="o">=</span> <span class="nf">malloc</span><span class="p">(</span><span class="n">len</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>		<span class="c1">// and twice for the actual variable.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">memcpy</span><span class="p">(</span><span class="n">n</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">n</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">[</span><span class="n">len</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">n</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>(We&rsquo;ll ignore the parser of the program, since it&rsquo;s quite verbose and doesn&rsquo;t actually do anything interesting.)</p>
<h3 id="the-problem">The Problem<a href="#the-problem" class="hanchor" ariaLabel="Anchor">#</a> </h3>
<p>Have you noticed a problem with this code?</p>
<p>How the heck do you free everything that you allocated?</p>
<p>Being the memory wizard that you are, you decide to traverse postorder the entire AST, freeing every node as you go. No biggie.</p>
<p>But what if one of your <code>malloc()</code>s failed during the midst of construction? What if you ran out of memory? What if you add more node types &ndash; say, unary operators? You&rsquo;d have to make amendments to your freeing function. Ternary operators? You&rsquo;d have to make another amendment. Every <code>malloc()</code> call also comes up with a header &ndash; for your tiny little NODE_NUMBER, you&rsquo;d have (enum + padding + op + padding + two pointers) = 32 bytes for the node itself, and likely half of that additionally for the header. You end up littering all over your heap, which end up to also be terrible news for your cache, as well.</p>
<p>This is just painful. You decide to read more about memory allocation in C. Then you came across arenas.</p>
<hr>
<h3 id="the-solution">The Solution<a href="#the-solution" class="hanchor" ariaLabel="Anchor">#</a> </h3>
<p>The concept of arenas is simple. In a program like this, many allocations share the same lifetime, so it doesn&rsquo;t really make sense for you to individually allocate every single one of them, only to free them all at the same time. An arena is just some chunk of memory that you use to store all your data that shares the same lifetime.</p>
<p>What does that look like in practice? Let&rsquo;s try rewriting your AST builder with an arena:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">buffer</span><span class="p">;</span>	<span class="c1">// The actual memory itself
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">size_t</span> <span class="n">capacity</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">size_t</span> <span class="n">offset</span><span class="p">;</span>		<span class="c1">// Basically, &#34;how much did we already &#39;allocate&#39;?&#34;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span> <span class="n">Arena</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">Arena</span> <span class="nf">arena_create</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">cap</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">Arena</span> <span class="n">a</span> <span class="o">=</span> <span class="p">{</span> <span class="nf">malloc</span><span class="p">(</span><span class="n">cap</span><span class="p">),</span> <span class="n">cap</span><span class="p">,</span> <span class="mi">0</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">a</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="o">*</span><span class="nf">arena_alloc</span><span class="p">(</span><span class="n">Arena</span> <span class="o">*</span><span class="n">a</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">size_t</span> <span class="n">aligned</span> <span class="o">=</span> <span class="p">(</span><span class="n">a</span><span class="o">-&gt;</span><span class="n">offset</span> <span class="o">+</span> <span class="mi">7</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="mi">7</span><span class="p">;</span>	<span class="c1">// Bit hacking to align to 8 bytes
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">aligned</span> <span class="o">+</span> <span class="n">size</span> <span class="o">&gt;</span> <span class="n">a</span><span class="o">-&gt;</span><span class="n">capacity</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&#34;Arena OOM</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="nf">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">a</span><span class="o">-&gt;</span><span class="n">buffer</span> <span class="o">+</span> <span class="n">aligned</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">a</span><span class="o">-&gt;</span><span class="n">offset</span> <span class="o">=</span> <span class="n">aligned</span> <span class="o">+</span> <span class="n">size</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">p</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">arena_destroy</span><span class="p">(</span><span class="n">Arena</span> <span class="o">*</span><span class="n">a</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nf">free</span><span class="p">(</span><span class="n">a</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>The magic here lies in the line <code>void *p = a-&gt;buffer + aligned;</code>. We calculate and return some chunk of aligned, allocated memory that the user asks for, without ever doing any manual allocation, because we&rsquo;ve already done that! <strong>One</strong> <code>malloc()</code> is all you need.</p>
<p>You don&rsquo;t need to even make substantial changes to the rest of your code; it&rsquo;s all analogous.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-diff" data-lang="diff"><span class="line"><span class="cl">static Node *make_var(const char *name, size_t len) {
</span></span><span class="line"><span class="cl"><span class="gd">-   Node *n = malloc(sizeof(Node));	// malloc() once for the node...
</span></span></span><span class="line"><span class="cl"><span class="gd"></span><span class="gi">+	Node *n = arena_alloc(p-&gt;arena, sizeof(Node));
</span></span></span><span class="line"><span class="cl"><span class="gi"></span>
</span></span><span class="line"><span class="cl">   	n-&gt;type = NODE_VAR;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="gd">-   n-&gt;name = malloc(len + 1);		// and twice for the actual variable.
</span></span></span><span class="line"><span class="cl"><span class="gd"></span><span class="gi">+	char *var = arena_alloc(p-&gt;arena, len + 1);
</span></span></span><span class="line"><span class="cl"><span class="gi"></span><span class="gd">-   memcpy(n-&gt;name, name, len);
</span></span></span><span class="line"><span class="cl"><span class="gd"></span><span class="gi">+	memcpy(var, name, len);
</span></span></span><span class="line"><span class="cl"><span class="gi"></span><span class="gd">-   n-&gt;name[len] = &#39;\0&#39;;
</span></span></span><span class="line"><span class="cl"><span class="gd"></span><span class="gi">+	var[len] = &#39;\0&#39;;
</span></span></span><span class="line"><span class="cl"><span class="gi"></span>
</span></span><span class="line"><span class="cl"><span class="gi">+	n-&gt;name = var;
</span></span></span><span class="line"><span class="cl"><span class="gi"></span>    return n;
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></div><hr>
<h3 id="finishing-thoughts">Finishing Thoughts<a href="#finishing-thoughts" class="hanchor" ariaLabel="Anchor">#</a> </h3>
<p>Free yourself from <code>malloc()</code> hell. If for some reason you find yourself needing to do a lot of manual allocations, &hellip; you don&rsquo;t! <em>Every</em> object that shares the same lifetime can be organized into a single arena &ndash; then you can just allocate and deallocate only once.</p>
<p>For a little extra content, I benchmarked both approaches. Note the amount of allocs and frees: the manual approach has 45 of each, while the arena approach only has 2 (one for the actual input).</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="o">[</span>svi@nixos:~/temp<span class="o">]</span>$ cc -o arena_ast arena_ast.c
</span></span><span class="line"><span class="cl"><span class="o">[</span>svi@nixos:~/temp<span class="o">]</span>$ cc -o manual_ast manual_ast.c
</span></span><span class="line"><span class="cl"><span class="o">[</span>svi@nixos:~/temp<span class="o">]</span>$ valgrind ./arena_ast
</span></span><span class="line"><span class="cl"><span class="o">==</span><span class="nv">2270451</span><span class="o">==</span> Memcheck, a memory error <span class="nv">detector</span>
</span></span><span class="line"><span class="cl"><span class="o">==</span><span class="nv">2270451</span><span class="o">==</span> Copyright <span class="o">(</span>C<span class="o">)</span> 2002-2024, and GNU GPL<span class="s1">&#39;d, by Julian Seward et al.
</span></span></span><span class="line"><span class="cl"><span class="s1">==2270451== Using Valgrind-3.26.0 and LibVEX; rerun with -h for copyright info
</span></span></span><span class="line"><span class="cl"><span class="s1">==2270451== Command: ./arena_ast
</span></span></span><span class="line"><span class="cl"><span class="s1">==2270451==
</span></span></span><span class="line"><span class="cl"><span class="s1">Input:  a + b + c + d + e + a + b + c + d + e + a + b + c + d + e
</span></span></span><span class="line"><span class="cl"><span class="s1">Result: 15.00  (assuming var=1)
</span></span></span><span class="line"><span class="cl"><span class="s1">Arena:  1048 bytes used
</span></span></span><span class="line"><span class="cl"><span class="s1">==2270451==
</span></span></span><span class="line"><span class="cl"><span class="s1">==2270451== HEAP SUMMARY:
</span></span></span><span class="line"><span class="cl"><span class="s1">==2270451==     in use at exit: 0 bytes in 0 blocks
</span></span></span><span class="line"><span class="cl"><span class="s1">==2270451==   total heap usage: 2 allocs, 2 frees, 5,120 bytes allocated
</span></span></span><span class="line"><span class="cl"><span class="s1">==2270451==
</span></span></span><span class="line"><span class="cl"><span class="s1">==2270451== All heap blocks were freed -- no leaks are possible
</span></span></span><span class="line"><span class="cl"><span class="s1">==2270451==
</span></span></span><span class="line"><span class="cl"><span class="s1">==2270451== For lists of detected and suppressed errors, rerun with: -s
</span></span></span><span class="line"><span class="cl"><span class="s1">==2270451== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
</span></span></span><span class="line"><span class="cl"><span class="s1">
</span></span></span><span class="line"><span class="cl"><span class="s1">[svi@nixos:~/temp]$ valgrind ./manual_ast
</span></span></span><span class="line"><span class="cl"><span class="s1">==2271111== Memcheck, a memory error detector
</span></span></span><span class="line"><span class="cl"><span class="s1">==2271111== Copyright (C) 2002-2024, and GNU GPL&#39;</span>d, by Julian Seward et al.
</span></span><span class="line"><span class="cl"><span class="o">==</span><span class="nv">2271111</span><span class="o">==</span> Using Valgrind-3.26.0 and LibVEX<span class="p">;</span> rerun with -h <span class="k">for</span> copyright <span class="nv">info</span>
</span></span><span class="line"><span class="cl"><span class="o">==</span><span class="nv">2271111</span><span class="o">==</span> Command: ./manual_ast
</span></span><span class="line"><span class="cl"><span class="o">==</span><span class="nv">2271111</span><span class="o">==</span>
</span></span><span class="line"><span class="cl">Input:  a + b + c + d + e + a + b + c + d + e + a + b + c + d + e
</span></span><span class="line"><span class="cl">Result: 15.00
</span></span><span class="line"><span class="cl"><span class="o">==</span><span class="nv">2271111</span><span class="o">==</span>
</span></span><span class="line"><span class="cl"><span class="o">==</span><span class="nv">2271111</span><span class="o">==</span> HEAP SUMMARY:
</span></span><span class="line"><span class="cl"><span class="o">==</span><span class="nv">2271111</span><span class="o">==</span>     in use at exit: <span class="m">0</span> bytes in <span class="m">0</span> <span class="nv">blocks</span>
</span></span><span class="line"><span class="cl"><span class="o">==</span><span class="nv">2271111</span><span class="o">==</span>   total heap usage: <span class="m">45</span> allocs, <span class="m">45</span> frees, 1,982 bytes <span class="nv">allocated</span>
</span></span><span class="line"><span class="cl"><span class="o">==</span><span class="nv">2271111</span><span class="o">==</span>
</span></span><span class="line"><span class="cl"><span class="o">==</span><span class="nv">2271111</span><span class="o">==</span> All heap blocks were freed -- no leaks are <span class="nv">possible</span>
</span></span><span class="line"><span class="cl"><span class="o">==</span><span class="nv">2271111</span><span class="o">==</span>
</span></span><span class="line"><span class="cl"><span class="o">==</span><span class="nv">2271111</span><span class="o">==</span> For lists of detected and suppressed errors, rerun with: -s
</span></span><span class="line"><span class="cl"><span class="o">==</span><span class="nv">2271111</span><span class="o">==</span> ERROR SUMMARY: <span class="m">0</span> errors from <span class="m">0</span> contexts <span class="o">(</span>suppressed: <span class="m">0</span> from 0<span class="o">)</span>
</span></span></code></pre></div><p>Have fun!</p>

      </div></div>

  
    

  

  
    

  
</article>

  </div>

  
    <footer class="footer">
  <div class="footer__inner">
    
      <div class="copyright">
        <span>© 2025 Powered by <a href="https://gohugo.io">Hugo</a></span>
    
      <span>:: <a href="https://github.com/panr/hugo-theme-terminal" target="_blank">Theme</a> made by <a href="https://github.com/panr" target="_blank">panr</a></span>
      </div>
  </div>
</footer>






<script type="text/javascript" src="/bundle.min.js"></script>





  
</div>

</body>
</html>
